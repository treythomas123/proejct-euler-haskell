-- Solution to Project Euler problem 61
-- By Trey Thomas
--
-- Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
-- are all figurate (polygonal) numbers and are generated by the following
-- formulae:
--
-- Triangle
-- P(3,n) = n(n+1)/2
-- 1, 3, 6, 10, 15, ...
--
-- Square
-- P(4,n) = n2
-- 1, 4, 9, 16, 25, ...
--
-- Pentagonal
-- P(5,n) = n(3n−1)/2
-- 1, 5, 12, 22, 35, ...
--
-- Hexagonal
-- P(6,n) = n(2n−1)
-- 1, 6, 15, 28, 45, ...
--
-- Heptagonal
-- P(7,n) = n(5n−3)/2
-- 1, 7, 18, 34, 55, ...
--
-- Octagonal
-- P(8,n) = n(3n−2)
-- 1, 8, 21, 40, 65, ...
--
-- The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
-- interesting properties.
--
-- The set is cyclic, in that the last two digits of each number is the first
-- two digits of the next number (including the last number with the first).
-- Each polygonal type: triangle (P(3,127) = 8128), square (P(4,91) = 8281), and
-- pentagonal (P(5,44) = 2882), is represented by a different number in the set.
-- This is the only set of 4-digit numbers with this property.
--
-- Find the sum of the only ordered set of six cyclic 4-digit numbers for which
-- each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
-- octagonal, is represented by a different number in the set.

import Data.List
import Control.Monad

fourDigitElements :: [Int] -> [Int]
fourDigitElements = takeWhile ((<5) . length . show) . dropWhile ((<4) . length . show)

polygonals :: Int -> [Int]
polygonals s = [ (n^2 * (s-2) - n*(s-4)) `div` 2 | n <- [1..] ]

canLink :: Int -> Int -> Bool
canLink a b = lastTwo a == firstTwo b
    where
        firstTwo = (read::String->Int) . take 2 . show
        lastTwo = (read::String->Int) . take 2 . drop 2 . show

findChains :: [[Int]] -> [[Int]]
findChains [x] = [x]
findChains (x:xs) = foldl extendChains startingChains xs
    where
        startingChains = map (:[]) x
        extendChains chains newLinks = concat $ map (extendChain newLinks) chains
        extendChain newLinks chain = [ chain ++ [newLink] | newLink<-newLinks, canLink (last chain) newLink ]

findCycles :: [[Int]] -> [[Int]]
findCycles = filter isCycle . findChains
    where
        isCycle c = (not . null) c && canLink (last c) (head c)

main = print $ sum $ head $ concat $ map findCycles $ permutations fourDigitPolygonalSets
    where
        fourDigitPolygonalSets = map (fourDigitElements . polygonals) [3..8]
